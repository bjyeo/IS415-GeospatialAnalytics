{
  "hash": "257f08a84b8230d0ae17d179ea28ed81",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 2\"\nauthor: \"Bao Jie Yeo\"\ndate: '2024-08-23'\nexecute: \n  eval: true\n  echo: true\n  freeze: true\neditor_options: \n  chunk_output_type: inline\n---\n\n\n## Loading Packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, tidyverse, tmap)\n```\n:::\n\n\n## Import Geospatial Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_read(dsn = \"data/geospatial\",\n                layer = \"MP14_SUBZONE_WEB_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\Users\\Home\\Desktop\\bjyeo\\IS415-GeospatialAnalytics\\HandsOnEx\\Ex02\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 10 features:\n   OBJECTID SUBZONE_NO       SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1         1          1    MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2         2          1    PEARL'S HILL    OTSZ01      Y          OUTRAM\n3         3          3       BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4         4          8  HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5         5          3         REDHILL    BMSZ03      N     BUKIT MERAH\n6         6          7  ALEXANDRA HILL    BMSZ07      N     BUKIT MERAH\n7         7          9   BUKIT HO SWEE    BMSZ09      N     BUKIT MERAH\n8         8          2     CLARKE QUAY    SRSZ02      Y SINGAPORE RIVER\n9         9         13 PASIR PANJANG 1    QTSZ13      N      QUEENSTOWN\n10       10          7       QUEENSWAY    QTSZ07      N      QUEENSTOWN\n   PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1          MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2          OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3          SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4          BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5          BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n6          BM CENTRAL REGION       CR 9D286521EF5E3B59 2014-12-05 25358.82\n7          BM CENTRAL REGION       CR 7839A8577144EFE2 2014-12-05 27680.06\n8          SR CENTRAL REGION       CR 48661DC0FBA09F7A 2014-12-05 29253.21\n9          QT CENTRAL REGION       CR 1F721290C421BFAB 2014-12-05 22077.34\n10         QT CENTRAL REGION       CR 3580D2AFFBEE914C 2014-12-05 24168.31\n     Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1  29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2  29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3  29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4  29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5  30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n6  29991.38   4428.913  1030378.8 MULTIPOLYGON (((25899.7 297...\n7  30230.86   3275.312   551732.0 MULTIPOLYGON (((27746.95 30...\n8  30222.86   2208.619   290184.7 MULTIPOLYGON (((29351.26 29...\n9  29893.78   6571.323  1084792.3 MULTIPOLYGON (((20996.49 30...\n10 30104.18   3454.239   631644.3 MULTIPOLYGON (((24472.11 29...\n```\n\n\n:::\n:::\n\n\n::: callout-warning\n### Output Behaviour\n\nWhen we call `mpsz`, only the first 10 records are shown because the object is too large to be displayed in its entirety. By default, R only displays the first 10 records.\n:::\n\n## Import Attribute Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata <- read_csv(\"data/aspatial/respopagesextod2011to2020.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 984656 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): PA, SZ, AG, Sex, TOD\ndbl (2): Pop, Time\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\nCalling `spec` on a dataframe displays its structure, including the data types of each column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspec(popdata)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncols(\n  PA = col_character(),\n  SZ = col_character(),\n  AG = col_character(),\n  Sex = col_character(),\n  TOD = col_character(),\n  Pop = col_double(),\n  Time = col_double()\n)\n```\n\n\n:::\n:::\n\n## Data Preparation\n\n### Data Wrangling\n\nAs part of data preparation, we will use:\n* `pivot_wider` to convert the data from long to wide format\n* `mutate`, `filter`, `group_by` and `select` to clean and filter the data\n\nWe do not need to import **tidyr** or **dplyr** because they are already loaded as part of the **tidyverse** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata2020 <- popdata %>%\n  filter(Time == 2020) %>%\n  group_by(PA, SZ, AG) %>%\n  summarise(`POP` = sum(`Pop`)) %>%\n  ungroup() %>%\n  pivot_wider(names_from = AG, values_from = POP) %>%\n  mutate(`YOUNG` = rowSums(.[3:6]) + rowSums(.[14])) %>%\n  mutate(`ECONOMY ACTIVE` = rowSums(.[7:13])+rowSums(.[15])) %>%\n  mutate(`AGED` = rowSums(.[16:21])) %>%\n  mutate(`TOTAL` = rowSums(.[3:21])) %>%\n  mutate(`DEPENDENCY` = (`YOUNG` + `AGED`)/`ECONOMY ACTIVE`) %>%\n  select(`PA`, `SZ`, `YOUNG`, `ECONOMY ACTIVE`, `AGED`, `TOTAL`, `DEPENDENCY`)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'PA', 'SZ'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n:::\n\n::: {.callout-caution collapse=\"true\"}\n### Code Analysis\n\nThe above code looks daunting, so let's try to break down what it's doing.\n\n1. Filter data for only year 2020 from the dataset\n2. Group data by PA (Planning Area), SZ (Subzone), AG (Age Group). We use `group_by` to prepare data for summarization\n3. Calculate total population for each unique combination of PA, SZ, AG\n4. Call `pivot_wider` to transform data from long to wide. Resultingly, each unique value in AG becomes a new column, with POP values filling the cells. This creates a table where each row represents a unique PA-SZ combination, with columns for each age group\n5. Calculate new demographic variables (YOUNG, ECONOMY ACTIVE, AGED, TOTAL, DEPENDENCY)\n6. Finally, select columns for the output dataset; keeping only key demographic summary variables and identifiers\n:::\n\n### Merging Geospatial and Attribute Data\n\nUsing `mutate_at`, we convert the PA and SZ columns to uppercase. This is to ensure consistency in the data before merging with the geospatial data. The `.vars` argument refers to the columns to be modified, while the `.funs` argument specifies the function applied.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata2020 <- popdata2020 |>\n  mutate_at(.vars = vars(PA, SZ),\n            .funs = list(toupper)) |>\n  filter(`ECONOMY ACTIVE` > 0)\n```\n:::\n\n\nNext, call `left_join` to join the geospatial data and attribute data on planning subzone name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_pop2020 <- left_join(mpsz, popdata2020,\n                          by = c(\"SUBZONE_N\" = \"SZ\"))\n```\n:::\n\n\nThe `write_rds` command saves the merged dataset as an RDS file for future loading.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(mpsz_pop2020, \"data/mpsz_pop2020.rds\")\n```\n:::\n\n\n## Plotting Choropleth Maps\n\n### Hacky method of plotting choropleth maps\n\nThe first approach we can utilize is using `qtm` from the **tmap** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\nqtm(mpsz_pop2020, fill = \"DEPENDENCY\")\n```\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n### Using `tmap` elements\n\nInstead of using `qtm`, we can use `tm_shape` and `tm_fill` to create a choropleth map. One advantage of this approach is the ability to customize the map layout and elements. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_grid(alpha =0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n```\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n### Drawing base map\n\n`tm_polygons()` can be used to show the base map without any fill. This may be useful when we want to show only the boundaries of the planning subzones.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_polygons()\n```\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n### Drawing chloropleth map using `tm_polygons()`\n\nHere, we use `tm_polygons()` to draw a choropleth map based on the `DEPENDENCY` variable. The darker highlighted regions represent planning subzones with higher dependency ratios.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_polygons(\"DEPENDENCY\")\n```\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n### Drawing chloropleth map using `tm_fill()`\n\nInstead of using `tm_polygons()`, we can use `tm_fill()` to draw the choropleth map. This function allows us to specify the fill color based on the `DEPENDENCY` variable. We might want to use fill over polygons when the boundaries are not the main focus of the map. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\")\n```\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n### Drawing chloropleth map with `tm_borders()`\n\nBy adding borders to the chloropleth map, we can better distinguish between planning subzones. The `tm_borders()` function allows us to customize the border line width and transparency.\n\nAside from line width and transparency, we can also specify the border color using the `col` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\") +\n  tm_borders(lwd = 0.1,  alpha = 1, col = \"darkgreen\")\n```\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n## Data Classifications\n\n### Using built-in methods\n\nWithout specifying the number of classes, `tm_fill()` will use the default classification method. In this case, it uses the `quantile` method to classify the data. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"quantile\",\n          palette = \"plasma\") +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n### DIY: Comparison of classification methods\n\nUsing what you had learned, prepare choropleth maps by using different classification methods supported by tmap and compare their differences. Prepare a grid showing the maps side by side of different tmap styles.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create maps with different classification methods\nmap_fixed <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\", style = \"fixed\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(title = \"Fixed\")\n\nmap_sd <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\", style = \"sd\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(title = \"Standard Deviation\")\n\nmap_equal <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\", style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(title = \"Equal Interval\")\n\nmap_pretty <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\", style = \"pretty\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(title = \"Pretty (Default)\")\n\nmap_quantile <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\", style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(title = \"Quantile\")\n\nmap_kmeans <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\", style = \"kmeans\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(title = \"K-means\")\n\nmap_hclust <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\", style = \"hclust\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(title = \"Hierarchical Clustering\")\n\nmap_bclust <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\", style = \"bclust\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(title = \"Bagged Clustering\")\n\nmap_fisher <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\", style = \"fisher\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(title = \"Fisher-Jenks\")\n\nmap_jenks <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\", style = \"jenks\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(title = \"Jenks (Natural Breaks)\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_arrange(map_hclust, map_bclust, map_fisher, map_jenks, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCommittee Member: 1(1) 2(1) 3(1) 4(1) 5(1) 6(1) 7(1) 8(1) 9(1) 10(1)\nComputing Hierarchical Clustering\n```\n\n\n:::\n:::\n\n\nWe can see from above that the different classification methods result in different choropleth maps. The choice of classification method can affect how the data is represented and interpreted. \n\nHere we are concerned with the distribution of dependency ratios. In my opinion, using the `jenks` classification method provides a clearer representation of the data distribution since it groups the data into classes based on natural breaks.\n\n### DIY: Comparison of different numbered classes\n\nUsing the same dataset, prepare choropleth maps with different numbers of classes and compare their differences. Prepare a grid showing the maps side by side with different numbers of classes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create maps with different number of classes\nmap_2c <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\", n = 3, style = \"pretty\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(title = \"2 Classes\")\n\nmap_6c <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\", n = 4, style = \"pretty\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(title = \"6 Classes\")\n\nmap_10c <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\", n = 5, style = \"pretty\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(title = \"10 Classes\")\n\nmap_20c <- tm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\", n = 10, style = \"pretty\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(title = \"20 Classes\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_arrange(map_2c, map_6c, map_10c, map_20c, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\nWhen we add more classes, the map becomes more detailed, but it may also become harder to interpret. The map with 2 classes is too simplistic, while the map with 20 classes is too detailed to tell the finer differences between the colors on the map.\n\n### Using custom breaks\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(mpsz_pop2020$DEPENDENCY)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.0000  0.6519  0.7025  0.7742  0.7645 19.0000      92 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00)) +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Values have found that are higher than the highest break\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n## Color Schemes\n\n### Exploring Color Palettes\n\nRunning the code chunk below opens an interactive Shiny app that allows you to explore different color palettes offered by default in RColorBrewer.\n\nKnowing what color palettes are available can help you choose the most appropriate one for your data visualization. For example, some of the best color palettes to use to when presenting data to colorblind individuals are `viridis`, `cividis`, and `colorblind`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# pacman::p_load(shiny, shinyjs)\n# \n# tmaptools::palette_explorer()\n```\n:::\n\n\n\n### ColorBrewer Palette\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"Greens\") +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n### Reverse ColorBrewer Palette\n\nAdding the `reverse` argument to the `palette` parameter will reverse the color scheme. This can be useful to highlight the highest values with a lighter color.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n### Viridis Palette\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"viridis\") +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n## Map Layouts\n\n### Adding Map Legend\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\", \n          style = \"jenks\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone \\n(Jenks classification)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            legend.outside = FALSE,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n### Map Style\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"natural\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap style set to \"natural\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nother available styles are: \"white\", \"gray\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n### Adding Scale Bar\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tm_scale_bar(width = 0.15)\n```\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n### Cartographic Elements\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n```\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\n## Plotting Multiple Chloropleth Maps\n\nHere, we are plotting 2 maps side by side to represent the distribution of young and aged populations in planning subzones.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(c(\"YOUNG\", \"AGED\"),\n          style = \"equal\", \n          palette = \"Blues\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\")) +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"white\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap style set to \"white\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\n### Defining group_by variable in `tm_facets()`\n\nHere, we use the `tm_facets()` function to create maps for each region in Singapore.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          thres.poly = 0) + \n  tm_facets(by=\"REGION_N\", \n            free.coords=TRUE, \n            drop.shapes=TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The argument drop.shapes has been renamed to drop.units, and is\ntherefore deprecated\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\n### Using `tm_arrange()`\n\nInstead of using `tm_facets()`, we can use `tm_arrange()` to create multiple maps side by side. This function allows us to arrange maps in a grid layout.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyoungmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"YOUNG\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\nagedmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"AGED\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\ntmap_arrange(youngmap, agedmap, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\n## Mapping Spatial Object based on Selection Criterion\n\nWhat we are trying to do here is to plot a choropleth map of the Central Region based on the dependency ratio. The legend is a histogram that shows the distribution of dependency ratios in the region.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N == \"CENTRAL REGION\", ])+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in pre_process_gt(x, interactive = interactive, orig_crs =\ngm$shape.orig_crs): legend.width controls the width of the legend within a map.\nPlease use legend.outside.size to control the width of the outside legend\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Ex02_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Ex02_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}